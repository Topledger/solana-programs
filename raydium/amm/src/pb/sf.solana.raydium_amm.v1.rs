// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instructions {
    #[prost(message, repeated, tag = "1")]
    pub instructions: ::prost::alloc::vec::Vec<Meta>,
}
/// Meta holds block and transaction context for each instruction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Meta {
    #[prost(string, optional, tag = "1")]
    pub block_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub block_time: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3")]
    pub block_slot: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "4")]
    pub tx_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "5")]
    pub instruction_index: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub is_inner_instruction: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub inner_instruction_index: ::core::option::Option<u32>,
    /// Program ID (Raydium AMM V4)
    #[prost(string, optional, tag = "8")]
    pub dapp: ::core::option::Option<::prost::alloc::string::String>,
    /// e.g., "swapBaseIn", "initialize"
    #[prost(string, optional, tag = "9")]
    pub instruction_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Unified arguments - This contains optional fields
    #[prost(message, optional, tag = "10")]
    pub args: ::core::option::Option<FlatArg>,
    /// Map of account names to addresses from IDL
    #[prost(map = "string, string", tag = "11")]
    pub input_accounts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Transaction signer
    #[prost(string, optional, tag = "12")]
    pub signer: ::core::option::Option<::prost::alloc::string::String>,
    /// Outer program ID if inner instruction
    #[prost(string, optional, tag = "13")]
    pub outer_program: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Fees {
    #[prost(uint64, optional, tag = "1")]
    pub min_separate_numerator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub min_separate_denominator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub trade_numerator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub trade_denominator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub pnl_numerator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "6")]
    pub pnl_denominator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "7")]
    pub swap_fee_numerator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "8")]
    pub swap_fee_denominator: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LastOrderDistance {
    #[prost(uint64, optional, tag = "1")]
    pub last_order_numerator: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub last_order_denominator: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NeedTake {
    #[prost(uint64, optional, tag = "1")]
    pub need_take_coin: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub need_take_pc: ::core::option::Option<u64>,
}
/// Used in SimulateInfo and potentially internally
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwapInstructionBaseIn {
    #[prost(uint64, optional, tag = "1")]
    pub amount_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub minimum_amount_out: ::core::option::Option<u64>,
}
/// Used in SimulateInfo and potentially internally
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwapInstructionBaseOut {
    #[prost(uint64, optional, tag = "1")]
    pub max_amount_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub amount_out: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbInitializeLayout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub nonce: u32,
    #[prost(uint64, tag = "2")]
    pub open_time: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbInitialize2Layout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub nonce: u32,
    #[prost(uint64, tag = "2")]
    pub open_time: u64,
    #[prost(uint64, tag = "3")]
    pub init_pc_amount: u64,
    #[prost(uint64, tag = "4")]
    pub init_coin_amount: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbMonitorStepLayout {
    /// u16 in IDL
    #[prost(uint32, tag = "1")]
    pub plan_order_limit: u32,
    /// u16 in IDL
    #[prost(uint32, tag = "2")]
    pub place_order_limit: u32,
    /// u16 in IDL
    #[prost(uint32, tag = "3")]
    pub cancel_order_limit: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbDepositLayout {
    #[prost(uint64, tag = "1")]
    pub max_coin_amount: u64,
    #[prost(uint64, tag = "2")]
    pub max_pc_amount: u64,
    #[prost(uint64, tag = "3")]
    pub base_side: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbWithdrawLayout {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
}
/// No args
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbMigrateToOpenBookLayout {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbSetParamsLayout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(uint64, optional, tag = "2")]
    pub value: ::core::option::Option<u64>,
    /// publicKey in IDL maps to string
    #[prost(string, optional, tag = "3")]
    pub new_pubkey: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub fees: ::core::option::Option<Fees>,
    #[prost(message, optional, tag = "5")]
    pub last_order_distance: ::core::option::Option<LastOrderDistance>,
    #[prost(message, optional, tag = "6")]
    pub need_take_amounts: ::core::option::Option<NeedTake>,
}
/// No args
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbWithdrawPnlLayout {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbWithdrawSrmLayout {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbSwapBaseInLayout {
    #[prost(uint64, tag = "1")]
    pub amount_in: u64,
    #[prost(uint64, tag = "2")]
    pub minimum_amount_out: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbPreInitializeLayout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub nonce: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbSwapBaseOutLayout {
    #[prost(uint64, tag = "1")]
    pub max_amount_in: u64,
    #[prost(uint64, tag = "2")]
    pub amount_out: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbSimulateInfoLayout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub param: u32,
    #[prost(message, optional, tag = "2")]
    pub swap_base_in_value: ::core::option::Option<SwapInstructionBaseIn>,
    #[prost(message, optional, tag = "3")]
    pub swap_base_out_value: ::core::option::Option<SwapInstructionBaseOut>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbAdminCancelOrdersLayout {
    /// u16 in IDL
    #[prost(uint32, tag = "1")]
    pub limit: u32,
}
/// No args
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PbCreateConfigAccountLayout {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PbUpdateConfigAccountLayout {
    /// u8 in IDL
    #[prost(uint32, tag = "1")]
    pub param: u32,
    /// publicKey in IDL maps to string
    #[prost(string, tag = "2")]
    pub owner: ::prost::alloc::string::String,
}
/// Mirrors the Switch statement in the Python parser, holding args for one specific instruction type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstructionArgs {
    #[prost(
        oneof = "instruction_args::Instruction",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"
    )]
    pub instruction: ::core::option::Option<instruction_args::Instruction>,
}
/// Nested message and enum types in `InstructionArgs`.
pub mod instruction_args {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instruction {
        #[prost(message, tag = "1")]
        Initialize(super::PbInitializeLayout),
        #[prost(message, tag = "2")]
        Initialize2(super::PbInitialize2Layout),
        #[prost(message, tag = "3")]
        MonitorStep(super::PbMonitorStepLayout),
        #[prost(message, tag = "4")]
        Deposit(super::PbDepositLayout),
        #[prost(message, tag = "5")]
        Withdraw(super::PbWithdrawLayout),
        #[prost(message, tag = "6")]
        MigrateToOpenBook(super::PbMigrateToOpenBookLayout),
        #[prost(message, tag = "7")]
        SetParams(super::PbSetParamsLayout),
        #[prost(message, tag = "8")]
        WithdrawPnl(super::PbWithdrawPnlLayout),
        #[prost(message, tag = "9")]
        WithdrawSrm(super::PbWithdrawSrmLayout),
        #[prost(message, tag = "10")]
        SwapBaseIn(super::PbSwapBaseInLayout),
        #[prost(message, tag = "11")]
        PreInitialize(super::PbPreInitializeLayout),
        #[prost(message, tag = "12")]
        SwapBaseOut(super::PbSwapBaseOutLayout),
        #[prost(message, tag = "13")]
        SimulateInfo(super::PbSimulateInfoLayout),
        #[prost(message, tag = "14")]
        AdminCancelOrders(super::PbAdminCancelOrdersLayout),
        #[prost(message, tag = "15")]
        CreateConfigAccount(super::PbCreateConfigAccountLayout),
        /// Note: Python parser has ReservedX types, omitted here as IDL doesn't define args/accounts for them.
        #[prost(message, tag = "16")]
        UpdateConfigAccount(super::PbUpdateConfigAccountLayout),
    }
}
/// FlatArg combines all possible arguments from all instructions for consistent output structure.
/// Use 'optional' for fields that were missing when zero in the original issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlatArg {
    #[prost(uint32, optional, tag = "1")]
    pub nonce: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "2")]
    pub open_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub init_pc_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub init_coin_amount: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "5")]
    pub plan_order_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub place_order_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub cancel_order_limit: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub max_coin_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "9")]
    pub max_pc_amount: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "10")]
    pub base_side: ::core::option::Option<u64>,
    /// Used by Withdraw, WithdrawSrm
    #[prost(uint64, optional, tag = "11")]
    pub amount: ::core::option::Option<u64>,
    /// Used by SetParams, SimulateInfo, UpdateConfigAccount
    #[prost(uint32, optional, tag = "12")]
    pub param: ::core::option::Option<u32>,
    /// Used by SetParams
    #[prost(uint64, optional, tag = "13")]
    pub value: ::core::option::Option<u64>,
    /// Used by SetParams
    #[prost(string, optional, tag = "14")]
    pub new_pubkey: ::core::option::Option<::prost::alloc::string::String>,
    /// Used by SetParams
    #[prost(message, optional, tag = "15")]
    pub fees: ::core::option::Option<Fees>,
    /// Used by SetParams
    #[prost(message, optional, tag = "16")]
    pub last_order_distance: ::core::option::Option<LastOrderDistance>,
    /// Used by SetParams
    #[prost(message, optional, tag = "17")]
    pub need_take_amounts: ::core::option::Option<NeedTake>,
    /// Used by SwapBaseIn
    #[prost(uint64, optional, tag = "18")]
    pub amount_in: ::core::option::Option<u64>,
    /// Used by SwapBaseIn
    #[prost(uint64, optional, tag = "19")]
    pub minimum_amount_out: ::core::option::Option<u64>,
    /// Used by SwapBaseOut
    #[prost(uint64, optional, tag = "20")]
    pub max_amount_in: ::core::option::Option<u64>,
    /// Used by SwapBaseOut
    #[prost(uint64, optional, tag = "21")]
    pub amount_out: ::core::option::Option<u64>,
    /// Used by SimulateInfo
    #[prost(message, optional, tag = "22")]
    pub swap_base_in_value: ::core::option::Option<SwapInstructionBaseIn>,
    /// Used by SimulateInfo
    #[prost(message, optional, tag = "23")]
    pub swap_base_out_value: ::core::option::Option<SwapInstructionBaseOut>,
    /// Used by AdminCancelOrders
    #[prost(uint32, optional, tag = "24")]
    pub limit: ::core::option::Option<u32>,
    /// Used by UpdateConfigAccount
    #[prost(string, optional, tag = "25")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
}
